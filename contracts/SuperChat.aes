include "List.aes"
payable contract SuperChat =

  record user =
    { name  : string,
      about : string,
      image : string,
      owner : address }

  record message =
    { message : string,
      time    : int,
      sender  : address,
      seen    : bool }

  record fund =
    { sender      : address,
      time        : int,
      amount      : int,
      description : string }

  record state =
    { profile       : map(address, user),
      friends       : map(address, list(address)),
      requests      : map(address, list(address)),
      newest_friend : map(address, address),
      messages      : map(address, map(address, list(message))),
      funds         : map(address, map(address, list(fund))),
      admin         : address }

  stateful entrypoint init() : state =
    { profile       = {},
      friends       = {},
      requests      = {},
      newest_friend = {},
      messages      = {},
      funds         = {},
      admin         = Call.caller }

  private function check_admin(caller_address: address)  : bool =
    require(state.admin == caller_address, "Admin Only Function")
    true
  
  private function check_user(caller_address : address) : bool =
    require(Map.member(caller_address, state.profile), "User Not Found")
    true

  entrypoint empty_profile(caller_address: address) : user =
    let empty_profile : user = { name = "", about = "", image = "", owner = caller_address }
    empty_profile

  stateful entrypoint register_profile(name': string, about': string, image': string, owner': address) : user =
    let new_profile : user = { name = name', about = about', image = image', owner = owner' }
    put(state{ profile[owner'] = new_profile })
    new_profile

  entrypoint get_profile(caller_address: address) : user =
    Map.lookup_default(caller_address, state.profile, empty_profile(caller_address))

  entrypoint get_all_profile(caller_address: address) : map(address, user) =
    require((check_admin(caller_address) || check_user(caller_address)), "Unauthorized Access")
    state.profile

  stateful entrypoint send_friend_request(friends_address: address, caller_address: address) : list(address) =
    let empty_address_list : list(address) = [caller_address]
    switch(Map.lookup(friends_address, state.requests))
      None =>   only_one_friend_request(friends_address, empty_address_list)
      Some(x) => modify_friends_request(x, empty_address_list, friends_address)

  stateful function modify_friends_request(old_list: list(address), new_friend_list: list(address), friends_address: address) : list(address) =
    let new_list : list(address) = new_friend_list ++ old_list
    put(state{ requests[friends_address] = new_list })
    new_list

  stateful function only_one_friend_request(friends_address: address, new_friend_list: list(address)) : list(address) =
    put(state{ requests[friends_address] = new_friend_list })
    new_friend_list

  entrypoint get_friend_request(caller_address: address) : list(user) =
    let friends_request : list(user) = List.map((request) => Map.lookup_default(request, get_all_profile(caller_address), empty_profile(caller_address)), Map.lookup_default(caller_address, state.requests, []))
    friends_request

  stateful entrypoint reject_friend_request(caller_address: address, new_friends_address: address) : list(address) =
    let friend_request_list : list(address) = Map.lookup_default(caller_address, state.requests, [])
    let new_friend_request_list : list(address) = List.filter((request) => request != new_friends_address, friend_request_list)
    put(state{ requests[caller_address] = new_friend_request_list })
    new_friend_request_list

  stateful entrypoint accept_friend_request(caller_address: address, new_friends_address: address) : unit =
    let friend_request_list : list(address) = Map.lookup_default(caller_address, state.requests, [])
    let new_friend_request_list : list(address) = List.filter((request) => request != new_friends_address, friend_request_list)

    let friends_list : list(address) = Map.lookup_default(caller_address, state.friends, [])
    let request_senders_friend_list : list(address) = Map.lookup_default(new_friends_address, state.friends, [])

    let new_request_senders_friend_list : list(address) = caller_address::request_senders_friend_list
    let new_friends_list : list(address) = new_friends_address::friends_list

    let new_friendsMap : map(address, list(address)) = state.friends{ [caller_address] = new_friends_list, [new_friends_address] = new_request_senders_friend_list }
    put(state{ friends = new_friendsMap, requests[caller_address] = new_friend_request_list })

  entrypoint get_friends(caller_address: address) : list(user) =
    let friends : list(user) = List.map((friend) => Map.lookup_default(friend, get_all_profile(caller_address), empty_profile(caller_address)), Map.lookup_default(caller_address, state.friends, []))
    friends

  entrypoint get_all_friends(caller_address: address) : map(address, list(address)) = 
    check_admin(caller_address)
    state.friends

  stateful entrypoint send_message(sender': address, receiver: address, message': string) : message =
    let new_message : message = { message = message', time = Chain.timestamp, sender = sender', seen = false }
    let old_state_senders_messages : map(address, list(message)) = Map.lookup_default(sender', state.messages, {})
    let old_state_receiver_messages : map(address, list(message)) = Map.lookup_default(receiver, state.messages, {})

    let old_single_receiver_messages : list(message) = Map.lookup_default(sender', old_state_receiver_messages, [])
    let old_single_sender_messages : list(message) = Map.lookup_default(receiver, old_state_senders_messages, [])

    let new_single_receiver_messages : list(message) = new_message::old_single_receiver_messages
    let new_single_sender_messages : list(message) = new_message::old_single_sender_messages

    let new_state_senders_message : map(address, list(message)) = old_state_senders_messages{ [receiver] = new_single_sender_messages }
    let new_state_receivers_message : map(address, list(message)) = old_state_receiver_messages{ [sender'] = new_single_receiver_messages }

    let new_updated_state : map(address, map(address, list(message))) = state.messages{ [sender'] = new_state_senders_message, [receiver] = new_state_receivers_message }
    put(state{ messages = new_updated_state })
    new_message

  entrypoint get_user_messages(user_address: address) : map(address, list(message)) =
    Map.lookup_default(user_address, state.messages, {})

  entrypoint get_user_friend_messages(user_address: address, friend_address: address) : list(message) =
    let all_messages : map(address, list(message)) = get_user_messages(user_address)
    let friend_messages : list(message) = Map.lookup_default(friend_address, all_messages, [])
    friend_messages

  entrypoint get_all_messages(caller_address : address) : map(address, map(address, list(message))) = 
    check_admin(caller_address)
    state.messages

  payable stateful entrypoint send_fund(sender': address, receiver: address, description': string) : fund =
    require(get_user_balance(sender') > Call.value, "Insufficient Funds")

    let new_fund : fund = { sender = sender', time = Chain.timestamp, amount = Call.value, description = description' }
    let old_state_senders_funds : map(address, list(fund)) = Map.lookup_default(sender', state.funds, {})
    let old_state_receiver_funds : map(address, list(fund)) = Map.lookup_default(receiver, state.funds, {})

    let old_single_receiver_funds : list(fund) = Map.lookup_default(sender', old_state_receiver_funds, [])
    let old_single_sender_funds : list(fund) = Map.lookup_default(receiver, old_state_senders_funds, [])

    let new_single_receiver_funds : list(fund) = new_fund::old_single_receiver_funds
    let new_single_sender_funds : list(fund) = new_fund::old_single_sender_funds

    let new_state_senders_fund : map(address, list(fund)) = old_state_senders_funds{ [receiver] = new_single_sender_funds }
    let new_state_receivers_fund : map(address, list(fund)) = old_state_receiver_funds{ [sender'] = new_single_receiver_funds }

    let new_updated_state : map(address, map(address, list(fund))) = state.funds{ [sender'] = new_state_senders_fund, [receiver] = new_state_receivers_fund }
    Chain.spend(receiver, Call.value)
    put(state{ funds = new_updated_state })
    new_fund

  private function get_user_balance(user_address: address) : int = Chain.balance(user_address)

  entrypoint get_user_funds(user_address : address) : map(address, list(fund)) =
    Map.lookup_default(user_address, state.funds, {})

  entrypoint get_user_friend_fund(user_address: address, friend_address: address) : list(fund) =
    let all_funds : map(address, list(fund)) = get_user_funds(user_address)
    let friend_fund : list(fund) = Map.lookup_default(friend_address, all_funds, [])
    friend_fund

  entrypoint get_contract_balance(caller_address: address) : int = 
    check_admin(caller_address)
    Contract.balance

  entrypoint get_all_funds(caller_address : address): map(address, map(address, list(fund))) = 
    check_admin(caller_address)
    state.funds
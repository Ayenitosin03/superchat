include "List.aes"
payable contract SuperChat =

  record user =
    { name  : string,
      about : string,
      image : string,
      owner : address }

  record message =
    { content : string,
      time    : int,
      sender  : address }

  record fund =
    { sender      : address,
      time        : int,
      amount      : int,
      description : string }

  record state =
    { profile       : map(address, user),
      friends       : map(address, list(address)),
      requests      : map(address, list(address)),
      newest_friend : map(address, address),
      messages      : map(address, map(address, list(message))),
      funds         : map(address, map(address, list(fund))),
      admin         : address }

  stateful entrypoint init() : state =
    { profile       = {},
      friends       = {},
      requests      = {},
      newest_friend = {},
      messages      = {},
      funds         = {},
      admin         = Call.caller }

  private function check_admin() : bool =
    require(state.admin == Call.caller, "Unauthorized Access")
    true
  
  private function check_user() : bool =
    require(Map.member(Call.caller, state.profile), "User Not Found")
    true

  entrypoint empty_profile() : user =
    let empty_profile : user = { name = "", about = "", image = "", owner = Call.caller }
    empty_profile

  stateful entrypoint register_profile(name': string, about': string, image': string) : user =
    let new_profile : user = { name = name', about = about', image = image', owner = Call.caller }
    put(state{ profile[Call.caller] = new_profile })
    new_profile

  entrypoint get_profile() : user =
    Map.lookup_default(Call.caller, state.profile, empty_profile())

  entrypoint get_all_profile() : map(address, user) =
    (check_admin() || check_user())
    state.profile

  stateful entrypoint send_friend_request(friends_address: address) : list(address) =
    let empty_address_list : list(address) = [Call.caller]
    switch(Map.lookup(friends_address, state.requests))
      None =>   only_one_friend_request(friends_address, empty_address_list)
      Some(x) => modify_friends_request(x, empty_address_list, friends_address)

  stateful function modify_friends_request(old_list: list(address), new_friend_list: list(address), friends_address: address) : list(address) =
    let new_list : list(address) = new_friend_list ++ old_list
    put(state{ requests[friends_address] = new_list })
    new_list

  stateful function only_one_friend_request(friends_address: address, new_friend_list: list(address)) : list(address) =
    put(state{ requests[friends_address] = new_friend_list })
    new_friend_list

  entrypoint get_friend_request() : list(user) =
    let friends_request : list(user) = List.map((request) => Map.lookup_default(request, get_all_profile(), empty_profile()), Map.lookup_default(Call.caller, state.requests, []))
    friends_request

  stateful entrypoint reject_friend_request(new_friends_address: address) : list(address) =
    let friend_request_list : list(address) = Map.lookup_default(Call.caller, state.requests, [])
    let new_friend_request_list : list(address) = List.filter((request) => request != new_friends_address, friend_request_list)
    put(state{ requests[Call.caller] = new_friend_request_list })
    new_friend_request_list

  stateful entrypoint accept_friend_request(new_friends_address: address) : unit =
    let friend_request_list : list(address) = Map.lookup_default(Call.caller, state.requests, [])
    let new_friend_request_list : list(address) = List.filter((request) => request != new_friends_address, friend_request_list)

    let friends_list : list(address) = Map.lookup_default(Call.caller, state.friends, [])
    let request_senders_friend_list : list(address) = Map.lookup_default(new_friends_address, state.friends, [])

    let new_request_senders_friend_list : list(address) = Call.caller::request_senders_friend_list
    let new_friends_list : list(address) = new_friends_address::friends_list

    let new_friendsMap : map(address, list(address)) = state.friends{ [Call.caller] = new_friends_list, [new_friends_address] = new_request_senders_friend_list }
    put(state{ friends = new_friendsMap, requests[Call.caller] = new_friend_request_list })

  entrypoint get_friends() : list(user) =
    let friends : list(user) = List.map((friend) => Map.lookup_default(friend, get_all_profile(), empty_profile()), Map.lookup_default(Call.caller, state.friends, []))
    friends

  entrypoint get_all_friends() : map(address, list(address)) =
    check_admin()
    state.friends

  stateful entrypoint send_message(receiver: address, content': string) : message =
    let new_message : message = { content = content', time = Chain.timestamp, sender = Call.caller }
    let old_state_senders_messages : map(address, list(message)) = Map.lookup_default(Call.caller, state.messages, {})
    let old_state_receiver_messages : map(address, list(message)) = Map.lookup_default(receiver, state.messages, {})

    let old_single_receiver_messages : list(message) = Map.lookup_default(Call.caller, old_state_receiver_messages, [])
    let old_single_sender_messages : list(message) = Map.lookup_default(receiver, old_state_senders_messages, [])

    let new_single_receiver_messages : list(message) = new_message::old_single_receiver_messages
    let new_single_sender_messages : list(message) = new_message::old_single_sender_messages

    let new_state_senders_message : map(address, list(message)) = old_state_senders_messages{ [receiver] = new_single_sender_messages }
    let new_state_receivers_message : map(address, list(message)) = old_state_receiver_messages{ [Call.caller] = new_single_receiver_messages }

    let new_updated_state : map(address, map(address, list(message))) = state.messages{ [Call.caller] = new_state_senders_message, [receiver] = new_state_receivers_message }
    put(state{ messages = new_updated_state })
    new_message

  entrypoint get_user_messages() : map(address, list(message)) =
    Map.lookup_default(Call.caller, state.messages, {})

  entrypoint get_user_friend_messages(friend_address: address) : list(message) =
    Map.lookup_default(friend_address, get_user_messages(), [])

  entrypoint get_all_messages() : map(address, map(address, list(message))) = 
    check_admin()
    state.messages

  payable stateful entrypoint send_fund(receiver: address, description': string) : fund =
    require(get_user_balance() > Call.value, "Insufficient Funds")

    let new_fund : fund = { sender = Call.caller, time = Chain.timestamp, amount = Call.value, description = description' }
    let old_state_senders_funds : map(address, list(fund)) = Map.lookup_default(Call.caller, state.funds, {})
    let old_state_receiver_funds : map(address, list(fund)) = Map.lookup_default(receiver, state.funds, {})

    let old_single_receiver_funds : list(fund) = Map.lookup_default(Call.caller, old_state_receiver_funds, [])
    let old_single_sender_funds : list(fund) = Map.lookup_default(receiver, old_state_senders_funds, [])

    let new_single_receiver_funds : list(fund) = new_fund::old_single_receiver_funds
    let new_single_sender_funds : list(fund) = new_fund::old_single_sender_funds

    let new_state_senders_fund : map(address, list(fund)) = old_state_senders_funds{ [receiver] = new_single_sender_funds }
    let new_state_receivers_fund : map(address, list(fund)) = old_state_receiver_funds{ [Call.caller] = new_single_receiver_funds }

    let new_updated_state : map(address, map(address, list(fund))) = state.funds{ [Call.caller] = new_state_senders_fund, [receiver] = new_state_receivers_fund }
    Chain.spend(receiver, Call.value)
    put(state{ funds = new_updated_state })
    new_fund

  private function get_user_balance() : int = Chain.balance(Call.caller)

  entrypoint get_user_funds() : map(address, list(fund)) =
    Map.lookup_default(Call.caller, state.funds, {})

  entrypoint get_user_friend_fund(friend_address: address) : list(fund) =
    Map.lookup_default(friend_address, get_user_funds(), [])

  entrypoint get_contract_balance() : int = 
    check_admin()
    Contract.balance

  entrypoint get_all_funds() : map(address, map(address, list(fund))) = 
    check_admin()
    state.funds